/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.9.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { ExecuteMsg, Expiration, Timestamp, Uint64, CosmosMsgForEmpty, BankMsg, Uint128, StakingMsg, DistributionMsg, WasmMsg, Binary, Vote, Coin, Empty, Duration, Threshold, Decimal, InstantiateMsg, Voter, QueryMsg } from "./CW3Multisig.types";
import { CW3MultisigQueryClient, CW3MultisigClient } from "./CW3Multisig.client";
export const cW3MultisigQueryKeys = {
  contract: ([{
    contract: "cW3Multisig"
  }] as const),
  address: (contractAddress: string) => ([{
    ...cW3MultisigQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  threshold: (contractAddress: string, args?: Record<string, unknown>) => ([{
    ...cW3MultisigQueryKeys.address(contractAddress)[0],
    method: "threshold",
    args
  }] as const),
  proposal: (contractAddress: string, args?: Record<string, unknown>) => ([{
    ...cW3MultisigQueryKeys.address(contractAddress)[0],
    method: "proposal",
    args
  }] as const),
  listProposals: (contractAddress: string, args?: Record<string, unknown>) => ([{
    ...cW3MultisigQueryKeys.address(contractAddress)[0],
    method: "list_proposals",
    args
  }] as const),
  reverseProposals: (contractAddress: string, args?: Record<string, unknown>) => ([{
    ...cW3MultisigQueryKeys.address(contractAddress)[0],
    method: "reverse_proposals",
    args
  }] as const),
  vote: (contractAddress: string, args?: Record<string, unknown>) => ([{
    ...cW3MultisigQueryKeys.address(contractAddress)[0],
    method: "vote",
    args
  }] as const),
  listVotes: (contractAddress: string, args?: Record<string, unknown>) => ([{
    ...cW3MultisigQueryKeys.address(contractAddress)[0],
    method: "list_votes",
    args
  }] as const),
  voter: (contractAddress: string, args?: Record<string, unknown>) => ([{
    ...cW3MultisigQueryKeys.address(contractAddress)[0],
    method: "voter",
    args
  }] as const),
  listVoters: (contractAddress: string, args?: Record<string, unknown>) => ([{
    ...cW3MultisigQueryKeys.address(contractAddress)[0],
    method: "list_voters",
    args
  }] as const)
};
export interface CW3MultisigReactQuery<TResponse, TData = TResponse> {
  client: CW3MultisigQueryClient;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface CW3MultisigListVotersQuery<TData> extends CW3MultisigReactQuery<ListVotersResponse, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useCW3MultisigListVotersQuery<TData = ListVotersResponse>({
  client,
  args,
  options
}: CW3MultisigListVotersQuery<TData>) {
  return useQuery<ListVotersResponse, Error, TData>(cW3MultisigQueryKeys.listVoters(client.contractAddress, args), () => client.listVoters({
    limit: args.limit,
    startAfter: args.startAfter
  }), options);
}
export interface CW3MultisigVoterQuery<TData> extends CW3MultisigReactQuery<VoterResponse, TData> {
  args: {
    address: string;
  };
}
export function useCW3MultisigVoterQuery<TData = VoterResponse>({
  client,
  args,
  options
}: CW3MultisigVoterQuery<TData>) {
  return useQuery<VoterResponse, Error, TData>(cW3MultisigQueryKeys.voter(client.contractAddress, args), () => client.voter({
    address: args.address
  }), options);
}
export interface CW3MultisigListVotesQuery<TData> extends CW3MultisigReactQuery<ListVotesResponse, TData> {
  args: {
    limit?: number;
    proposalId: number;
    startAfter?: string;
  };
}
export function useCW3MultisigListVotesQuery<TData = ListVotesResponse>({
  client,
  args,
  options
}: CW3MultisigListVotesQuery<TData>) {
  return useQuery<ListVotesResponse, Error, TData>(cW3MultisigQueryKeys.listVotes(client.contractAddress, args), () => client.listVotes({
    limit: args.limit,
    proposalId: args.proposalId,
    startAfter: args.startAfter
  }), options);
}
export interface CW3MultisigVoteQuery<TData> extends CW3MultisigReactQuery<VoteResponse, TData> {
  args: {
    proposalId: number;
    voter: string;
  };
}
export function useCW3MultisigVoteQuery<TData = VoteResponse>({
  client,
  args,
  options
}: CW3MultisigVoteQuery<TData>) {
  return useQuery<VoteResponse, Error, TData>(cW3MultisigQueryKeys.vote(client.contractAddress, args), () => client.vote({
    proposalId: args.proposalId,
    voter: args.voter
  }), options);
}
export interface CW3MultisigReverseProposalsQuery<TData> extends CW3MultisigReactQuery<ReverseProposalsResponse, TData> {
  args: {
    limit?: number;
    startBefore?: number;
  };
}
export function useCW3MultisigReverseProposalsQuery<TData = ReverseProposalsResponse>({
  client,
  args,
  options
}: CW3MultisigReverseProposalsQuery<TData>) {
  return useQuery<ReverseProposalsResponse, Error, TData>(cW3MultisigQueryKeys.reverseProposals(client.contractAddress, args), () => client.reverseProposals({
    limit: args.limit,
    startBefore: args.startBefore
  }), options);
}
export interface CW3MultisigListProposalsQuery<TData> extends CW3MultisigReactQuery<ListProposalsResponse, TData> {
  args: {
    limit?: number;
    startAfter?: number;
  };
}
export function useCW3MultisigListProposalsQuery<TData = ListProposalsResponse>({
  client,
  args,
  options
}: CW3MultisigListProposalsQuery<TData>) {
  return useQuery<ListProposalsResponse, Error, TData>(cW3MultisigQueryKeys.listProposals(client.contractAddress, args), () => client.listProposals({
    limit: args.limit,
    startAfter: args.startAfter
  }), options);
}
export interface CW3MultisigProposalQuery<TData> extends CW3MultisigReactQuery<ProposalResponse, TData> {
  args: {
    proposalId: number;
  };
}
export function useCW3MultisigProposalQuery<TData = ProposalResponse>({
  client,
  args,
  options
}: CW3MultisigProposalQuery<TData>) {
  return useQuery<ProposalResponse, Error, TData>(cW3MultisigQueryKeys.proposal(client.contractAddress, args), () => client.proposal({
    proposalId: args.proposalId
  }), options);
}
export interface CW3MultisigThresholdQuery<TData> extends CW3MultisigReactQuery<ThresholdResponse, TData> {}
export function useCW3MultisigThresholdQuery<TData = ThresholdResponse>({
  client,
  options
}: CW3MultisigThresholdQuery<TData>) {
  return useQuery<ThresholdResponse, Error, TData>(cW3MultisigQueryKeys.threshold(client.contractAddress), () => client.threshold(), options);
}
export interface CW3MultisigCloseMutation {
  client: CW3MultisigClient;
  msg: {
    proposalId: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCW3MultisigCloseMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CW3MultisigCloseMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CW3MultisigCloseMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.close(msg, fee, memo, funds), options);
}
export interface CW3MultisigExecuteMutation {
  client: CW3MultisigClient;
  msg: {
    proposalId: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCW3MultisigExecuteMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CW3MultisigExecuteMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CW3MultisigExecuteMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.execute(msg, fee, memo, funds), options);
}
export interface CW3MultisigVoteMutation {
  client: CW3MultisigClient;
  msg: {
    proposalId: number;
    vote: Vote;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCW3MultisigVoteMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CW3MultisigVoteMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CW3MultisigVoteMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.vote(msg, fee, memo, funds), options);
}
export interface CW3MultisigProposeMutation {
  client: CW3MultisigClient;
  msg: {
    description: string;
    latest?: Expiration;
    msgs: CosmosMsgForEmpty[];
    title: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCW3MultisigProposeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CW3MultisigProposeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CW3MultisigProposeMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.propose(msg, fee, memo, funds), options);
}